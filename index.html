<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Парсер корзины Lego из файла</title>
    <style>
        body {
            font-family: sans-serif;
            line-height: 1.6;
            margin: 20px;
            background-color: #f4f4f4;
        }
        .container {
            max-width: 800px;
            margin: auto;
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        h1, h2 {
            color: #333;
            text-align: center;
        }
        .input-area {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 20px;
            align-items: center;
        }
        .input-area label {
            font-weight: bold;
            margin-bottom: 5px;
        }
        .input-area input[type="file"] {
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 100%;
            max-width: 500px;
            box-sizing: border-box;
        }
        input[type="file"]::file-selector-button {
            margin-right: 15px;
            border: none;
            background: #007bff;
            padding: 8px 12px;
            border-radius: 4px;
            color: #fff;
            cursor: pointer;
            transition: background-color .2s ease-in-out;
        }
        input[type="file"]::file-selector-button:hover {
            background: #0056b3;
        }
        .input-area button {
            padding: 12px 20px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            font-size: 1.1em;
            width: 100%;
            max-width: 300px;
        }
        .input-area button:hover {
            background-color: #218838;
        }
        .parts-list {
            margin-top: 20px;
            border-top: 1px solid #eee;
            padding-top: 20px;
        }
        .part-item {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
            padding: 10px;
            background-color: #f9f9f9;
            border: 1px solid #eee;
            border-radius: 4px;
        }
        .part-item img {
            flex-shrink: 0; /* Предотвращает сжатие изображения */
            max-width: 60px;
            max-height: 60px;
            border: 1px solid #ddd;
            object-fit: contain;
            /* Стили для ленивой загрузки - изображение изначально прозрачное */
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }
        .part-item img.loaded {
             opacity: 1;
        }
        .part-info {
            flex-grow: 1;
            min-width: 0; /* Помогает flexbox правильно обрабатывать перенос текста */
        }
        .part-name {
            font-weight: bold;
            color: #444;
            font-size: 0.95em;
            word-wrap: break-word; /* Перенос длинных названий */
        }
        .part-quantity, .part-price {
            color: #666;
            font-size: 0.9em;
        }
        .part-price {
             font-weight: bold;
             color: #333;
             margin-top: 4px;
        }
        .loading-message, .error-message, .info-message, .warning-message {
            text-align: center;
            padding: 15px;
            margin-top: 20px;
            border-radius: 4px;
        }
        .loading-message {
            background-color: #e0e0e0;
            color: #555;
        }
        .error-message {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .info-message {
            background-color: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        .warning-message {
            background-color: #fff3cd;
            color: #856404;
            border: 1px solid #ffeeba;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Парсер корзины Lego из файла</h1>
        <div class="input-area">
            <label for="htmlFileInput">Выберите сохраненный HTML файл корзины:</label>
            <input type="file" id="htmlFileInput" accept=".html, .htm">
            <button id="processFileButton">Обработать файл</button>
        </div>
        <div id="messageArea">
            <div class="info-message">
                <strong>Как использовать:</strong>
                <ol style="text-align: left; margin-top: 10px;">
                    <li>Откройте страницу с общей корзиной в браузере (например, <code style="background: #eee; padding: 2px 4px; border-radius: 3px;">https://shop-device.ru/sharebasket/...</code>).</li>
                    <li>Сохраните эту страницу на ваш компьютер (Ctrl+S или Файл → Сохранить как...). Выберите тип "HTML Only".</li>
                    <li>Нажмите "Выберите файл" и загрузите сохраненный HTML-файл.</li>
                    <li>Нажмите "Обработать файл".</li>
                </ol>
                 <div class="warning-message" style="margin-top: 10px; text-align: left;">
                    <strong>Примечание:</strong> Отображение цен зависит от правильности CSS-селектора <code>.basket-share-detail__item__price .price_value</code>. Если цены не показываются, проверьте HTML-код сохраненной страницы и при необходимости измените селектор в скрипте этого парсера.
                 </div>
            </div>
        </div>
        <div id="partsList" class="parts-list"></div>
    </div>

    <script>
        const fileInput = document.getElementById('htmlFileInput');
        const processButton = document.getElementById('processFileButton');
        const partsListDiv = document.getElementById('partsList');
        const messageArea = document.getElementById('messageArea');
        let imageObserver = null; // Переменная для хранения IntersectionObserver

        processButton.addEventListener('click', () => {
            partsListDiv.innerHTML = ''; // Очищаем предыдущий список
            clearMessages(); // Очищаем сообщения
            // Отключаем предыдущий наблюдатель, если он был
            if (imageObserver) {
                imageObserver.disconnect();
                imageObserver = null;
            }

            const file = fileInput.files[0];
            if (!file) {
                displayMessage("Пожалуйста, выберите HTML файл для обработки.", "warning");
                return;
            }

            displayMessage("Чтение файла...", "loading");

            const reader = new FileReader();
            reader.onload = (event) => {
                const htmlContent = event.target.result;
                clearLoadingMessage();

                if (!htmlContent) {
                    displayMessage("Не удалось прочитать содержимое файла.", "error");
                    return;
                }

                displayMessage("Анализ HTML...", "loading", true);

                try {
                    const parsedData = parseBasketHtml(htmlContent);
                    clearLoadingMessage();
                    displayParts(parsedData); // Отображаем структуру

                    if (parsedData.length === 0) {
                        displayMessage("Детали в файле не найдены или структура HTML не соответствует ожидаемой.", "warning", true);
                    } else {
                        displayMessage(`Найдено и отображено деталей: ${parsedData.length}`, "info", true);
                        initializeLazyLoading(); // Запускаем ленивую загрузку ПОСЛЕ добавления элементов
                    }
                } catch (error) {
                    console.error("Ошибка парсинга HTML:", error);
                    clearLoadingMessage();
                    displayMessage(`Ошибка при анализе HTML: ${error.message}. Проверьте файл и попробуйте снова.`, "error");
                }
            };

            reader.onerror = (event) => {
                console.error("Ошибка чтения файла:", event.target.error);
                clearMessages();
                displayMessage(`Ошибка при чтении файла: ${event.target.error.name}`, "error");
            };

            reader.readAsText(file); // Читаем файл как текст
        });

        /**
         * Парсит HTML-код корзины и извлекает данные о товарах.
         * @param {string} htmlString - HTML-код страницы.
         * @returns {Array<object>} Массив объектов { name, quantity, imageUrl, price }.
         */
        function parseBasketHtml(htmlString) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');
            const itemsContainer = doc.querySelector('.basket-share-detail__items');

            if (!itemsContainer) {
                console.warn("Контейнер '.basket-share-detail__items' не найден.");
                return [];
            }

            const items = itemsContainer.querySelectorAll('.basket-share-detail__item');
            const partsData = [];
            let baseUrl = 'https://shop-device.ru';
            const baseTag = doc.querySelector('base[href]');
            if (baseTag && baseTag.href && baseTag.href.startsWith('http')) {
                baseUrl = baseTag.href.replace(/\/$/, '');
                 console.log(`Using base URL from <base> tag: ${baseUrl}`);
            } else {
                 console.log(`Using default base URL: ${baseUrl}`);
            }

            items.forEach((item, index) => {
                const nameElement = item.querySelector('.basket-share-detail__item__name a.dark_link');
                const quantityElement = item.querySelector('.basket-share-detail__item__quantity');
                const imageLink = item.querySelector('.basket-share-detail__item__image a.thumb');
                const imageElement = imageLink ? imageLink.querySelector('img') : item.querySelector('.basket-share-detail__item__image img');
                // --- ИЗВЛЕЧЕНИЕ ЦЕНЫ ---
                // !!! ВНИМАНИЕ: Замените селектор ниже, если цена не находится !!!
                const priceElement = item.querySelector('.basket-share-detail__item__price .price_value'); // Пример селектора, может потребоваться настройка
                let price = null; // Используем null, если цена не найдена

                if (priceElement) {
                    const priceText = priceElement.textContent.trim();
                    // Очищаем от валюты, пробелов и заменяем запятую на точку для parseFloat
                    const cleanedPriceText = priceText.replace(/руб\.?/i, '').replace(/\s+/g, '').replace(',', '.');
                    const parsedPrice = parseFloat(cleanedPriceText);
                    if (!isNaN(parsedPrice)) {
                        price = parsedPrice;
                    } else {
                         console.warn(`Could not parse price from text: "${priceText}" for item ${index}`);
                    }
                } else {
                     console.warn(`Price element not found using selector '.basket-share-detail__item__price .price_value' for item ${index}`);
                }
                // --- КОНЕЦ ИЗВЛЕЧЕНИЯ ЦЕНЫ ---

                let name = nameElement ? nameElement.textContent.trim() : 'Название не найдено';
                let quantity = 0;
                if (quantityElement) {
                    const quantityText = quantityElement.textContent.trim();
                    const match = quantityText.match(/(\d+)/);
                    if (match) quantity = parseInt(match[1], 10);
                }

                let imageUrl = null; // Используем null если URL не найден
                if (imageElement) {
                    let potentialSrc = imageElement.getAttribute('data-src') || imageElement.getAttribute('src');
                    if (potentialSrc) {
                        if (potentialSrc.startsWith('/')) {
                            imageUrl = baseUrl + potentialSrc;
                        } else if (potentialSrc.startsWith('http')) {
                            imageUrl = potentialSrc;
                        } else {
                             console.warn(`Ignoring potential local/invalid image path: ${potentialSrc} for item ${index}`);
                        }
                    }
                } else {
                     console.warn(`Image element not found for item ${index}`);
                }


                if (name !== 'Название не найдено' && quantity > 0) {
                    partsData.push({ name, quantity, imageUrl, price }); // Добавляем цену в объект
                } else {
                    console.warn("Skipping item due to missing name or quantity:", item);
                }
            });

            return partsData;
        }

        /**
         * Отображает список деталей на странице (без загрузки изображений).
         * @param {Array<object>} parts - Массив деталей.
         */
        function displayParts(parts) {
            partsListDiv.innerHTML = '<h2>Содержимое корзины из файла</h2>';
            if (!parts || parts.length === 0) {
                return;
            }

            parts.forEach(part => {
                const itemDiv = document.createElement('div');
                itemDiv.classList.add('part-item');

                const img = document.createElement('img');
                // Устанавливаем data-src для ленивой загрузки, src оставляем пустым или с заглушкой
                img.dataset.src = part.imageUrl || 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'; // Используем data-src
                img.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'; // Заглушка
                img.alt = part.name.substring(0, 50);
                img.classList.add('lazy-load'); // Добавляем класс для IntersectionObserver
                img.onerror = () => {
                    img.alt = 'Ошибка загр.';
                    img.style.border = '1px solid red';
                    img.classList.add('loaded'); // Показываем даже если ошибка
                    console.warn(`Failed to load image: ${img.dataset.src}`);
                    // Убедимся, что observer перестает наблюдать за этим элементом
                     if (imageObserver) imageObserver.unobserve(img);
                };
                img.onload = () => {
                     img.classList.add('loaded'); // Делаем видимым после загрузки
                     // Убедимся, что observer перестает наблюдать за этим элементом
                     if (imageObserver) imageObserver.unobserve(img);
                }

                const infoDiv = document.createElement('div');
                infoDiv.classList.add('part-info');

                const nameP = document.createElement('p');
                nameP.classList.add('part-name');
                nameP.textContent = part.name;

                const quantityP = document.createElement('p');
                quantityP.classList.add('part-quantity');
                quantityP.textContent = `Количество: ${part.quantity}`;

                infoDiv.appendChild(nameP);
                infoDiv.appendChild(quantityP);

                // Отображение цены, если она была найдена
                if (part.price !== null) {
                    const priceP = document.createElement('p');
                    priceP.classList.add('part-price');
                    // Форматируем цену (например, с 2 знаками после запятой и "руб.")
                    priceP.textContent = `Цена: ${part.price.toLocaleString('ru-RU', { style: 'currency', currency: 'RUB', minimumFractionDigits: 0, maximumFractionDigits: 2 })}`;
                    infoDiv.appendChild(priceP);
                } else {
                     const priceP = document.createElement('p');
                     priceP.classList.add('part-price');
                     priceP.textContent = `Цена: не найдена`;
                     infoDiv.appendChild(priceP);
                }

                itemDiv.appendChild(img);
                itemDiv.appendChild(infoDiv);
                partsListDiv.appendChild(itemDiv);
            });
        }

         /**
         * Инициализирует IntersectionObserver для ленивой загрузки изображений.
         */
        function initializeLazyLoading() {
            const lazyImages = partsListDiv.querySelectorAll('img.lazy-load');

            if (!lazyImages.length) return; // Нечего наблюдать

            // Настройки для Observer: немного заранее начинать загрузку
            const observerOptions = {
                root: null, // относительно viewport
                rootMargin: '0px 0px 200px 0px', // Начать загрузку за 200px до появления снизу
                threshold: 0.01 // Как только хотя бы 1% виден
            };

            imageObserver = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const img = entry.target;
                        // console.log(`Loading image: ${img.dataset.src}`); // Отладка
                        img.src = img.dataset.src; // Заменяем src на реальный URL из data-src
                        img.classList.remove('lazy-load'); // Больше не нужно отслеживать
                        // img.onload и img.onerror сами отключат наблюдение через unobserve
                    }
                });
            }, observerOptions);

            // Начинаем наблюдение за каждым изображением
            lazyImages.forEach(img => {
                imageObserver.observe(img);
            });
        }


        /**
         * Отображает сообщение для пользователя.
         * @param {string} text - Текст сообщения.
         * @param {string} type - Тип сообщения (info, error, warning, loading).
         * @param {boolean} append - Добавлять сообщение или заменять существующие.
         */
        function displayMessage(text, type = "info", append = false) {
            if (!append && type !== 'loading') {
                clearMessages(false);
            } else if (!append) {
                 clearMessages(true);
            }

            const messageDiv = document.createElement('div');
            messageDiv.innerHTML = text;
            messageDiv.classList.add(`${type}-message`);
            messageArea.appendChild(messageDiv);
        }

        /**
         * Удаляет сообщения.
         * @param {boolean} all - Удалить все сообщения или только не-info и не-loading.
         */
        function clearMessages(all = true) {
             const initialInfoMessage = messageArea.querySelector('.info-message:has(strong)'); // Находим изначальное сообщение
             const types = ['.error-message', '.warning-message', '.loading-message'];
             if(all) {
                 types.push('.info-message'); // Если удаляем все, то и info тоже
             }

            types.forEach(selector => {
                messageArea.querySelectorAll(selector).forEach(msg => {
                     // Не удаляем изначальное сообщение с инструкцией, если не 'all'
                    if (msg !== initialInfoMessage || all) {
                         msg.remove();
                    }
                });
            });
        }

        /** Удаляет сообщения о загрузке */
        function clearLoadingMessage() {
            messageArea.querySelectorAll('.loading-message').forEach(msg => msg.remove());
        }
    </script>
</body>
</html>
